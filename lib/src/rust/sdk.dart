// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'duplicates.dart';
import 'errors.dart';
import 'events.dart';
import 'frb_generated.dart';
import 'models.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<BreezSdkLiquid> connect({required ConnectRequest req}) =>
    FlutterBreezLiquid.instance.api.crateSdkConnect(req: req);

Config defaultConfig({required LiquidNetwork network, String? breezApiKey}) =>
    FlutterBreezLiquid.instance.api.crateSdkDefaultConfig(network: network, breezApiKey: breezApiKey);

LNInvoice parseInvoice({required String input}) =>
    FlutterBreezLiquid.instance.api.crateSdkParseInvoice(input: input);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BreezSdkLiquid>>
abstract class BreezSdkLiquid implements RustOpaqueInterface {
  Future<void> acceptPaymentProposedFees({required AcceptPaymentProposedFeesRequest req});

  Stream<SdkEvent> addEventListener();

  void backup({required BackupRequest req});

  Future<String> buyBitcoin({required BuyBitcoinRequest req});

  CheckMessageResponse checkMessage({required CheckMessageRequest req});

  Future<CreateBolt12InvoiceResponse> createBolt12Invoice({required CreateBolt12InvoiceRequest req});

  Future<void> disconnect();

  void emptyWalletCache();

  Future<List<Rate>> fetchFiatRates();

  Future<LightningPaymentLimitsResponse> fetchLightningLimits();

  Future<OnchainPaymentLimitsResponse> fetchOnchainLimits();

  Future<FetchPaymentProposedFeesResponse> fetchPaymentProposedFees({
    required FetchPaymentProposedFeesRequest req,
  });

  Future<GetInfoResponse> getInfo();

  Future<Payment?> getPayment({required GetPaymentRequest req});

  Future<List<FiatCurrency>> listFiatCurrencies();

  Future<List<Payment>> listPayments({required ListPaymentsRequest req});

  Future<List<RefundableSwap>> listRefundables();

  Future<LnUrlCallbackStatus> lnurlAuth({required LnUrlAuthRequestData reqData});

  Future<LnUrlPayResult> lnurlPay({required LnUrlPayRequest req});

  Future<LnUrlWithdrawResult> lnurlWithdraw({required LnUrlWithdrawRequest req});

  Future<InputType> parse({required String input});

  Future<SendPaymentResponse> payOnchain({required PayOnchainRequest req});

  Future<PrepareBuyBitcoinResponse> prepareBuyBitcoin({required PrepareBuyBitcoinRequest req});

  Future<PrepareLnUrlPayResponse> prepareLnurlPay({required PrepareLnUrlPayRequest req});

  Future<PreparePayOnchainResponse> preparePayOnchain({required PreparePayOnchainRequest req});

  Future<PrepareReceiveResponse> prepareReceivePayment({required PrepareReceiveRequest req});

  Future<PrepareRefundResponse> prepareRefund({required PrepareRefundRequest req});

  Future<PrepareSendResponse> prepareSendPayment({required PrepareSendRequest req});

  Future<ReceivePaymentResponse> receivePayment({required ReceivePaymentRequest req});

  Future<RecommendedFees> recommendedFees();

  Future<RefundResponse> refund({required RefundRequest req});

  Future<void> registerWebhook({required String webhookUrl});

  Future<void> rescanOnchainSwaps();

  void restore({required RestoreRequest req});

  Future<SendPaymentResponse> sendPayment({required SendPaymentRequest req});

  SignMessageResponse signMessage({required SignMessageRequest req});

  Future<void> sync();

  Future<void> unregisterWebhook();
}
