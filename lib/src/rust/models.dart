// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'models.freezed.dart';

class AcceptPaymentProposedFeesRequest {
  final FetchPaymentProposedFeesResponse response;

  const AcceptPaymentProposedFeesRequest({required this.response});

  @override
  int get hashCode => response.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AcceptPaymentProposedFeesRequest &&
          runtimeType == other.runtimeType &&
          response == other.response;
}

class AesSuccessActionData {
  final String description;
  final String ciphertext;
  final String iv;

  const AesSuccessActionData({required this.description, required this.ciphertext, required this.iv});

  @override
  int get hashCode => description.hashCode ^ ciphertext.hashCode ^ iv.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AesSuccessActionData &&
          runtimeType == other.runtimeType &&
          description == other.description &&
          ciphertext == other.ciphertext &&
          iv == other.iv;
}

class AesSuccessActionDataDecrypted {
  final String description;
  final String plaintext;

  const AesSuccessActionDataDecrypted({required this.description, required this.plaintext});

  @override
  int get hashCode => description.hashCode ^ plaintext.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AesSuccessActionDataDecrypted &&
          runtimeType == other.runtimeType &&
          description == other.description &&
          plaintext == other.plaintext;
}

@freezed
sealed class AesSuccessActionDataResult with _$AesSuccessActionDataResult {
  const AesSuccessActionDataResult._();

  const factory AesSuccessActionDataResult.decrypted({required AesSuccessActionDataDecrypted data}) =
      AesSuccessActionDataResult_Decrypted;
  const factory AesSuccessActionDataResult.errorStatus({required String reason}) =
      AesSuccessActionDataResult_ErrorStatus;
}

@freezed
sealed class Amount with _$Amount {
  const Amount._();

  const factory Amount.bitcoin({required BigInt amountMsat}) = Amount_Bitcoin;
  const factory Amount.currency({required String iso4217Code, required BigInt fractionalAmount}) =
      Amount_Currency;
}

class AssetBalance {
  final String assetId;
  final BigInt balanceSat;
  final String? name;
  final String? ticker;
  final double? balance;

  const AssetBalance({required this.assetId, required this.balanceSat, this.name, this.ticker, this.balance});

  @override
  int get hashCode =>
      assetId.hashCode ^ balanceSat.hashCode ^ name.hashCode ^ ticker.hashCode ^ balance.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AssetBalance &&
          runtimeType == other.runtimeType &&
          assetId == other.assetId &&
          balanceSat == other.balanceSat &&
          name == other.name &&
          ticker == other.ticker &&
          balance == other.balance;
}

class AssetInfo {
  final String name;
  final String ticker;
  final double amount;
  final double? fees;

  const AssetInfo({required this.name, required this.ticker, required this.amount, this.fees});

  @override
  int get hashCode => name.hashCode ^ ticker.hashCode ^ amount.hashCode ^ fees.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AssetInfo &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          ticker == other.ticker &&
          amount == other.amount &&
          fees == other.fees;
}

class AssetMetadata {
  final String assetId;
  final String name;
  final String ticker;
  final int precision;
  final String? fiatId;

  const AssetMetadata({
    required this.assetId,
    required this.name,
    required this.ticker,
    required this.precision,
    this.fiatId,
  });

  @override
  int get hashCode =>
      assetId.hashCode ^ name.hashCode ^ ticker.hashCode ^ precision.hashCode ^ fiatId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AssetMetadata &&
          runtimeType == other.runtimeType &&
          assetId == other.assetId &&
          name == other.name &&
          ticker == other.ticker &&
          precision == other.precision &&
          fiatId == other.fiatId;
}

class BackupRequest {
  final String? backupPath;

  const BackupRequest({this.backupPath});

  @override
  int get hashCode => backupPath.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BackupRequest && runtimeType == other.runtimeType && backupPath == other.backupPath;
}

class BitcoinAddressData {
  final String address;
  final Network network;
  final BigInt? amountSat;
  final String? label;
  final String? message;

  const BitcoinAddressData({
    required this.address,
    required this.network,
    this.amountSat,
    this.label,
    this.message,
  });

  @override
  int get hashCode =>
      address.hashCode ^ network.hashCode ^ amountSat.hashCode ^ label.hashCode ^ message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BitcoinAddressData &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          network == other.network &&
          amountSat == other.amountSat &&
          label == other.label &&
          message == other.message;
}

@freezed
sealed class BlockchainExplorer with _$BlockchainExplorer {
  const BlockchainExplorer._();

  const factory BlockchainExplorer.electrum({required String url}) = BlockchainExplorer_Electrum;
  const factory BlockchainExplorer.esplora({required String url, required bool useWaterfalls}) =
      BlockchainExplorer_Esplora;
}

class BlockchainInfo {
  final int liquidTip;
  final int bitcoinTip;

  const BlockchainInfo({required this.liquidTip, required this.bitcoinTip});

  @override
  int get hashCode => liquidTip.hashCode ^ bitcoinTip.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BlockchainInfo &&
          runtimeType == other.runtimeType &&
          liquidTip == other.liquidTip &&
          bitcoinTip == other.bitcoinTip;
}

enum BuyBitcoinProvider { moonpay }

class BuyBitcoinRequest {
  final PrepareBuyBitcoinResponse prepareResponse;
  final String? redirectUrl;

  const BuyBitcoinRequest({required this.prepareResponse, this.redirectUrl});

  @override
  int get hashCode => prepareResponse.hashCode ^ redirectUrl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BuyBitcoinRequest &&
          runtimeType == other.runtimeType &&
          prepareResponse == other.prepareResponse &&
          redirectUrl == other.redirectUrl;
}

class CheckMessageRequest {
  final String message;
  final String pubkey;
  final String signature;

  const CheckMessageRequest({required this.message, required this.pubkey, required this.signature});

  @override
  int get hashCode => message.hashCode ^ pubkey.hashCode ^ signature.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CheckMessageRequest &&
          runtimeType == other.runtimeType &&
          message == other.message &&
          pubkey == other.pubkey &&
          signature == other.signature;
}

class CheckMessageResponse {
  final bool isValid;

  const CheckMessageResponse({required this.isValid});

  @override
  int get hashCode => isValid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CheckMessageResponse && runtimeType == other.runtimeType && isValid == other.isValid;
}

class Config {
  final BlockchainExplorer liquidExplorer;
  final BlockchainExplorer bitcoinExplorer;
  final String workingDir;
  final LiquidNetwork network;
  final BigInt paymentTimeoutSec;
  final String? syncServiceUrl;
  final BigInt? zeroConfMaxAmountSat;
  final String? breezApiKey;
  final List<ExternalInputParser>? externalInputParsers;
  final bool useDefaultExternalInputParsers;
  final BigInt? onchainFeeRateLeewaySat;
  final List<AssetMetadata>? assetMetadata;
  final String? sideswapApiKey;
  final bool useMagicRoutingHints;

  const Config({
    required this.liquidExplorer,
    required this.bitcoinExplorer,
    required this.workingDir,
    required this.network,
    required this.paymentTimeoutSec,
    this.syncServiceUrl,
    this.zeroConfMaxAmountSat,
    this.breezApiKey,
    this.externalInputParsers,
    required this.useDefaultExternalInputParsers,
    this.onchainFeeRateLeewaySat,
    this.assetMetadata,
    this.sideswapApiKey,
    required this.useMagicRoutingHints,
  });

  @override
  int get hashCode =>
      liquidExplorer.hashCode ^
      bitcoinExplorer.hashCode ^
      workingDir.hashCode ^
      network.hashCode ^
      paymentTimeoutSec.hashCode ^
      syncServiceUrl.hashCode ^
      zeroConfMaxAmountSat.hashCode ^
      breezApiKey.hashCode ^
      externalInputParsers.hashCode ^
      useDefaultExternalInputParsers.hashCode ^
      onchainFeeRateLeewaySat.hashCode ^
      assetMetadata.hashCode ^
      sideswapApiKey.hashCode ^
      useMagicRoutingHints.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Config &&
          runtimeType == other.runtimeType &&
          liquidExplorer == other.liquidExplorer &&
          bitcoinExplorer == other.bitcoinExplorer &&
          workingDir == other.workingDir &&
          network == other.network &&
          paymentTimeoutSec == other.paymentTimeoutSec &&
          syncServiceUrl == other.syncServiceUrl &&
          zeroConfMaxAmountSat == other.zeroConfMaxAmountSat &&
          breezApiKey == other.breezApiKey &&
          externalInputParsers == other.externalInputParsers &&
          useDefaultExternalInputParsers == other.useDefaultExternalInputParsers &&
          onchainFeeRateLeewaySat == other.onchainFeeRateLeewaySat &&
          assetMetadata == other.assetMetadata &&
          sideswapApiKey == other.sideswapApiKey &&
          useMagicRoutingHints == other.useMagicRoutingHints;
}

class ConnectRequest {
  final Config config;
  final String? mnemonic;
  final String? passphrase;
  final Uint8List? seed;

  const ConnectRequest({required this.config, this.mnemonic, this.passphrase, this.seed});

  @override
  int get hashCode => config.hashCode ^ mnemonic.hashCode ^ passphrase.hashCode ^ seed.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConnectRequest &&
          runtimeType == other.runtimeType &&
          config == other.config &&
          mnemonic == other.mnemonic &&
          passphrase == other.passphrase &&
          seed == other.seed;
}

class CreateBolt12InvoiceRequest {
  final String offer;
  final String invoiceRequest;

  const CreateBolt12InvoiceRequest({required this.offer, required this.invoiceRequest});

  @override
  int get hashCode => offer.hashCode ^ invoiceRequest.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CreateBolt12InvoiceRequest &&
          runtimeType == other.runtimeType &&
          offer == other.offer &&
          invoiceRequest == other.invoiceRequest;
}

class CreateBolt12InvoiceResponse {
  final String invoice;

  const CreateBolt12InvoiceResponse({required this.invoice});

  @override
  int get hashCode => invoice.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CreateBolt12InvoiceResponse && runtimeType == other.runtimeType && invoice == other.invoice;
}

class CurrencyInfo {
  final String name;
  final int fractionSize;
  final int? spacing;
  final Symbol? symbol;
  final Symbol? uniqSymbol;
  final List<LocalizedName> localizedName;
  final List<LocaleOverrides> localeOverrides;

  const CurrencyInfo({
    required this.name,
    required this.fractionSize,
    this.spacing,
    this.symbol,
    this.uniqSymbol,
    required this.localizedName,
    required this.localeOverrides,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      fractionSize.hashCode ^
      spacing.hashCode ^
      symbol.hashCode ^
      uniqSymbol.hashCode ^
      localizedName.hashCode ^
      localeOverrides.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CurrencyInfo &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          fractionSize == other.fractionSize &&
          spacing == other.spacing &&
          symbol == other.symbol &&
          uniqSymbol == other.uniqSymbol &&
          localizedName == other.localizedName &&
          localeOverrides == other.localeOverrides;
}

class ExternalInputParser {
  final String providerId;
  final String inputRegex;
  final String parserUrl;

  const ExternalInputParser({required this.providerId, required this.inputRegex, required this.parserUrl});

  @override
  int get hashCode => providerId.hashCode ^ inputRegex.hashCode ^ parserUrl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ExternalInputParser &&
          runtimeType == other.runtimeType &&
          providerId == other.providerId &&
          inputRegex == other.inputRegex &&
          parserUrl == other.parserUrl;
}

class FetchPaymentProposedFeesRequest {
  final String swapId;

  const FetchPaymentProposedFeesRequest({required this.swapId});

  @override
  int get hashCode => swapId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FetchPaymentProposedFeesRequest && runtimeType == other.runtimeType && swapId == other.swapId;
}

class FetchPaymentProposedFeesResponse {
  final String swapId;
  final BigInt feesSat;
  final BigInt payerAmountSat;
  final BigInt receiverAmountSat;

  const FetchPaymentProposedFeesResponse({
    required this.swapId,
    required this.feesSat,
    required this.payerAmountSat,
    required this.receiverAmountSat,
  });

  @override
  int get hashCode =>
      swapId.hashCode ^ feesSat.hashCode ^ payerAmountSat.hashCode ^ receiverAmountSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FetchPaymentProposedFeesResponse &&
          runtimeType == other.runtimeType &&
          swapId == other.swapId &&
          feesSat == other.feesSat &&
          payerAmountSat == other.payerAmountSat &&
          receiverAmountSat == other.receiverAmountSat;
}

class FiatCurrency {
  final String id;
  final CurrencyInfo info;

  const FiatCurrency({required this.id, required this.info});

  @override
  int get hashCode => id.hashCode ^ info.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FiatCurrency && runtimeType == other.runtimeType && id == other.id && info == other.info;
}

class GetInfoResponse {
  final WalletInfo walletInfo;
  final BlockchainInfo blockchainInfo;

  const GetInfoResponse({required this.walletInfo, required this.blockchainInfo});

  @override
  int get hashCode => walletInfo.hashCode ^ blockchainInfo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GetInfoResponse &&
          runtimeType == other.runtimeType &&
          walletInfo == other.walletInfo &&
          blockchainInfo == other.blockchainInfo;
}

@freezed
sealed class GetPaymentRequest with _$GetPaymentRequest {
  const GetPaymentRequest._();

  const factory GetPaymentRequest.paymentHash({required String paymentHash}) = GetPaymentRequest_PaymentHash;
  const factory GetPaymentRequest.swapId({required String swapId}) = GetPaymentRequest_SwapId;
}

@freezed
sealed class InputType with _$InputType {
  const InputType._();

  const factory InputType.bitcoinAddress({required BitcoinAddressData address}) = InputType_BitcoinAddress;
  const factory InputType.liquidAddress({required LiquidAddressData address}) = InputType_LiquidAddress;
  const factory InputType.bolt11({required LNInvoice invoice}) = InputType_Bolt11;
  const factory InputType.bolt12Offer({required LNOffer offer, String? bip353Address}) =
      InputType_Bolt12Offer;
  const factory InputType.nodeId({required String nodeId}) = InputType_NodeId;
  const factory InputType.url({required String url}) = InputType_Url;
  const factory InputType.lnUrlPay({required LnUrlPayRequestData data, String? bip353Address}) =
      InputType_LnUrlPay;
  const factory InputType.lnUrlWithdraw({required LnUrlWithdrawRequestData data}) = InputType_LnUrlWithdraw;
  const factory InputType.lnUrlAuth({required LnUrlAuthRequestData data}) = InputType_LnUrlAuth;
  const factory InputType.lnUrlError({required LnUrlErrorData data}) = InputType_LnUrlError;
}

class LightningPaymentLimitsResponse {
  final Limits send;
  final Limits receive;

  const LightningPaymentLimitsResponse({required this.send, required this.receive});

  @override
  int get hashCode => send.hashCode ^ receive.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LightningPaymentLimitsResponse &&
          runtimeType == other.runtimeType &&
          send == other.send &&
          receive == other.receive;
}

class Limits {
  final BigInt minSat;
  final BigInt maxSat;
  final BigInt maxZeroConfSat;

  const Limits({required this.minSat, required this.maxSat, required this.maxZeroConfSat});

  @override
  int get hashCode => minSat.hashCode ^ maxSat.hashCode ^ maxZeroConfSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Limits &&
          runtimeType == other.runtimeType &&
          minSat == other.minSat &&
          maxSat == other.maxSat &&
          maxZeroConfSat == other.maxZeroConfSat;
}

class LiquidAddressData {
  final String address;
  final Network network;
  final String? assetId;
  final double? amount;
  final BigInt? amountSat;
  final String? label;
  final String? message;

  const LiquidAddressData({
    required this.address,
    required this.network,
    this.assetId,
    this.amount,
    this.amountSat,
    this.label,
    this.message,
  });

  @override
  int get hashCode =>
      address.hashCode ^
      network.hashCode ^
      assetId.hashCode ^
      amount.hashCode ^
      amountSat.hashCode ^
      label.hashCode ^
      message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LiquidAddressData &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          network == other.network &&
          assetId == other.assetId &&
          amount == other.amount &&
          amountSat == other.amountSat &&
          label == other.label &&
          message == other.message;
}

enum LiquidNetwork { mainnet, testnet, regtest }

@freezed
sealed class ListPaymentDetails with _$ListPaymentDetails {
  const ListPaymentDetails._();

  const factory ListPaymentDetails.liquid({String? assetId, String? destination}) = ListPaymentDetails_Liquid;
  const factory ListPaymentDetails.bitcoin({String? address}) = ListPaymentDetails_Bitcoin;
}

class ListPaymentsRequest {
  final List<PaymentType>? filters;
  final List<PaymentState>? states;
  final PlatformInt64? fromTimestamp;
  final PlatformInt64? toTimestamp;
  final int? offset;
  final int? limit;
  final ListPaymentDetails? details;
  final bool? sortAscending;

  const ListPaymentsRequest({
    this.filters,
    this.states,
    this.fromTimestamp,
    this.toTimestamp,
    this.offset,
    this.limit,
    this.details,
    this.sortAscending,
  });

  @override
  int get hashCode =>
      filters.hashCode ^
      states.hashCode ^
      fromTimestamp.hashCode ^
      toTimestamp.hashCode ^
      offset.hashCode ^
      limit.hashCode ^
      details.hashCode ^
      sortAscending.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListPaymentsRequest &&
          runtimeType == other.runtimeType &&
          filters == other.filters &&
          states == other.states &&
          fromTimestamp == other.fromTimestamp &&
          toTimestamp == other.toTimestamp &&
          offset == other.offset &&
          limit == other.limit &&
          details == other.details &&
          sortAscending == other.sortAscending;
}

class LNInvoice {
  final String bolt11;
  final Network network;
  final String payeePubkey;
  final String paymentHash;
  final String? description;
  final String? descriptionHash;
  final BigInt? amountMsat;
  final BigInt timestamp;
  final BigInt expiry;
  final List<RouteHint> routingHints;
  final Uint8List paymentSecret;
  final BigInt minFinalCltvExpiryDelta;

  const LNInvoice({
    required this.bolt11,
    required this.network,
    required this.payeePubkey,
    required this.paymentHash,
    this.description,
    this.descriptionHash,
    this.amountMsat,
    required this.timestamp,
    required this.expiry,
    required this.routingHints,
    required this.paymentSecret,
    required this.minFinalCltvExpiryDelta,
  });

  @override
  int get hashCode =>
      bolt11.hashCode ^
      network.hashCode ^
      payeePubkey.hashCode ^
      paymentHash.hashCode ^
      description.hashCode ^
      descriptionHash.hashCode ^
      amountMsat.hashCode ^
      timestamp.hashCode ^
      expiry.hashCode ^
      routingHints.hashCode ^
      paymentSecret.hashCode ^
      minFinalCltvExpiryDelta.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LNInvoice &&
          runtimeType == other.runtimeType &&
          bolt11 == other.bolt11 &&
          network == other.network &&
          payeePubkey == other.payeePubkey &&
          paymentHash == other.paymentHash &&
          description == other.description &&
          descriptionHash == other.descriptionHash &&
          amountMsat == other.amountMsat &&
          timestamp == other.timestamp &&
          expiry == other.expiry &&
          routingHints == other.routingHints &&
          paymentSecret == other.paymentSecret &&
          minFinalCltvExpiryDelta == other.minFinalCltvExpiryDelta;
}

class LNOffer {
  final String offer;
  final List<String> chains;
  final Amount? minAmount;
  final String? description;
  final BigInt? absoluteExpiry;
  final String? issuer;
  final String? signingPubkey;
  final List<LnOfferBlindedPath> paths;

  const LNOffer({
    required this.offer,
    required this.chains,
    this.minAmount,
    this.description,
    this.absoluteExpiry,
    this.issuer,
    this.signingPubkey,
    required this.paths,
  });

  @override
  int get hashCode =>
      offer.hashCode ^
      chains.hashCode ^
      minAmount.hashCode ^
      description.hashCode ^
      absoluteExpiry.hashCode ^
      issuer.hashCode ^
      signingPubkey.hashCode ^
      paths.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LNOffer &&
          runtimeType == other.runtimeType &&
          offer == other.offer &&
          chains == other.chains &&
          minAmount == other.minAmount &&
          description == other.description &&
          absoluteExpiry == other.absoluteExpiry &&
          issuer == other.issuer &&
          signingPubkey == other.signingPubkey &&
          paths == other.paths;
}

class LnOfferBlindedPath {
  final List<String> blindedHops;

  const LnOfferBlindedPath({required this.blindedHops});

  @override
  int get hashCode => blindedHops.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnOfferBlindedPath && runtimeType == other.runtimeType && blindedHops == other.blindedHops;
}

class LnUrlAuthRequestData {
  final String k1;
  final String? action;
  final String domain;
  final String url;

  const LnUrlAuthRequestData({required this.k1, this.action, required this.domain, required this.url});

  @override
  int get hashCode => k1.hashCode ^ action.hashCode ^ domain.hashCode ^ url.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnUrlAuthRequestData &&
          runtimeType == other.runtimeType &&
          k1 == other.k1 &&
          action == other.action &&
          domain == other.domain &&
          url == other.url;
}

class LnUrlErrorData {
  final String reason;

  const LnUrlErrorData({required this.reason});

  @override
  int get hashCode => reason.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnUrlErrorData && runtimeType == other.runtimeType && reason == other.reason;
}

class LnUrlInfo {
  final String? lnAddress;
  final String? lnurlPayComment;
  final String? lnurlPayDomain;
  final String? lnurlPayMetadata;
  final SuccessActionProcessed? lnurlPaySuccessAction;
  final SuccessAction? lnurlPayUnprocessedSuccessAction;
  final String? lnurlWithdrawEndpoint;

  const LnUrlInfo({
    this.lnAddress,
    this.lnurlPayComment,
    this.lnurlPayDomain,
    this.lnurlPayMetadata,
    this.lnurlPaySuccessAction,
    this.lnurlPayUnprocessedSuccessAction,
    this.lnurlWithdrawEndpoint,
  });

  @override
  int get hashCode =>
      lnAddress.hashCode ^
      lnurlPayComment.hashCode ^
      lnurlPayDomain.hashCode ^
      lnurlPayMetadata.hashCode ^
      lnurlPaySuccessAction.hashCode ^
      lnurlPayUnprocessedSuccessAction.hashCode ^
      lnurlWithdrawEndpoint.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnUrlInfo &&
          runtimeType == other.runtimeType &&
          lnAddress == other.lnAddress &&
          lnurlPayComment == other.lnurlPayComment &&
          lnurlPayDomain == other.lnurlPayDomain &&
          lnurlPayMetadata == other.lnurlPayMetadata &&
          lnurlPaySuccessAction == other.lnurlPaySuccessAction &&
          lnurlPayUnprocessedSuccessAction == other.lnurlPayUnprocessedSuccessAction &&
          lnurlWithdrawEndpoint == other.lnurlWithdrawEndpoint;
}

class LnUrlPayErrorData {
  final String paymentHash;
  final String reason;

  const LnUrlPayErrorData({required this.paymentHash, required this.reason});

  @override
  int get hashCode => paymentHash.hashCode ^ reason.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnUrlPayErrorData &&
          runtimeType == other.runtimeType &&
          paymentHash == other.paymentHash &&
          reason == other.reason;
}

class LnUrlPayRequest {
  final PrepareLnUrlPayResponse prepareResponse;

  const LnUrlPayRequest({required this.prepareResponse});

  @override
  int get hashCode => prepareResponse.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnUrlPayRequest &&
          runtimeType == other.runtimeType &&
          prepareResponse == other.prepareResponse;
}

class LnUrlPayRequestData {
  final String callback;
  final BigInt minSendable;
  final BigInt maxSendable;
  final String metadataStr;
  final int commentAllowed;
  final String domain;
  final bool allowsNostr;
  final String? nostrPubkey;
  final String? lnAddress;

  const LnUrlPayRequestData({
    required this.callback,
    required this.minSendable,
    required this.maxSendable,
    required this.metadataStr,
    required this.commentAllowed,
    required this.domain,
    required this.allowsNostr,
    this.nostrPubkey,
    this.lnAddress,
  });

  @override
  int get hashCode =>
      callback.hashCode ^
      minSendable.hashCode ^
      maxSendable.hashCode ^
      metadataStr.hashCode ^
      commentAllowed.hashCode ^
      domain.hashCode ^
      allowsNostr.hashCode ^
      nostrPubkey.hashCode ^
      lnAddress.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnUrlPayRequestData &&
          runtimeType == other.runtimeType &&
          callback == other.callback &&
          minSendable == other.minSendable &&
          maxSendable == other.maxSendable &&
          metadataStr == other.metadataStr &&
          commentAllowed == other.commentAllowed &&
          domain == other.domain &&
          allowsNostr == other.allowsNostr &&
          nostrPubkey == other.nostrPubkey &&
          lnAddress == other.lnAddress;
}

@freezed
sealed class LnUrlPayResult with _$LnUrlPayResult {
  const LnUrlPayResult._();

  const factory LnUrlPayResult.endpointSuccess({required LnUrlPaySuccessData data}) =
      LnUrlPayResult_EndpointSuccess;
  const factory LnUrlPayResult.endpointError({required LnUrlErrorData data}) = LnUrlPayResult_EndpointError;
  const factory LnUrlPayResult.payError({required LnUrlPayErrorData data}) = LnUrlPayResult_PayError;
}

class LnUrlPaySuccessData {
  final Payment payment;
  final SuccessActionProcessed? successAction;

  const LnUrlPaySuccessData({required this.payment, this.successAction});

  @override
  int get hashCode => payment.hashCode ^ successAction.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnUrlPaySuccessData &&
          runtimeType == other.runtimeType &&
          payment == other.payment &&
          successAction == other.successAction;
}

class LnUrlWithdrawRequest {
  final LnUrlWithdrawRequestData data;
  final BigInt amountMsat;
  final String? description;

  const LnUrlWithdrawRequest({required this.data, required this.amountMsat, this.description});

  @override
  int get hashCode => data.hashCode ^ amountMsat.hashCode ^ description.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnUrlWithdrawRequest &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          amountMsat == other.amountMsat &&
          description == other.description;
}

class LnUrlWithdrawRequestData {
  final String callback;
  final String k1;
  final String defaultDescription;
  final BigInt minWithdrawable;
  final BigInt maxWithdrawable;

  const LnUrlWithdrawRequestData({
    required this.callback,
    required this.k1,
    required this.defaultDescription,
    required this.minWithdrawable,
    required this.maxWithdrawable,
  });

  @override
  int get hashCode =>
      callback.hashCode ^
      k1.hashCode ^
      defaultDescription.hashCode ^
      minWithdrawable.hashCode ^
      maxWithdrawable.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnUrlWithdrawRequestData &&
          runtimeType == other.runtimeType &&
          callback == other.callback &&
          k1 == other.k1 &&
          defaultDescription == other.defaultDescription &&
          minWithdrawable == other.minWithdrawable &&
          maxWithdrawable == other.maxWithdrawable;
}

class LocaleOverrides {
  final String locale;
  final int? spacing;
  final Symbol symbol;

  const LocaleOverrides({required this.locale, this.spacing, required this.symbol});

  @override
  int get hashCode => locale.hashCode ^ spacing.hashCode ^ symbol.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LocaleOverrides &&
          runtimeType == other.runtimeType &&
          locale == other.locale &&
          spacing == other.spacing &&
          symbol == other.symbol;
}

class LocalizedName {
  final String locale;
  final String name;

  const LocalizedName({required this.locale, required this.name});

  @override
  int get hashCode => locale.hashCode ^ name.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LocalizedName &&
          runtimeType == other.runtimeType &&
          locale == other.locale &&
          name == other.name;
}

class MessageSuccessActionData {
  final String message;

  const MessageSuccessActionData({required this.message});

  @override
  int get hashCode => message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MessageSuccessActionData && runtimeType == other.runtimeType && message == other.message;
}

enum Network { bitcoin, testnet, signet, regtest }

class OnchainPaymentLimitsResponse {
  final Limits send;
  final Limits receive;

  const OnchainPaymentLimitsResponse({required this.send, required this.receive});

  @override
  int get hashCode => send.hashCode ^ receive.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OnchainPaymentLimitsResponse &&
          runtimeType == other.runtimeType &&
          send == other.send &&
          receive == other.receive;
}

@freezed
sealed class PayAmount with _$PayAmount {
  const PayAmount._();

  const factory PayAmount.bitcoin({required BigInt receiverAmountSat}) = PayAmount_Bitcoin;
  const factory PayAmount.asset({
    required String toAsset,
    required double receiverAmount,
    bool? estimateAssetFees,
    String? fromAsset,
  }) = PayAmount_Asset;
  const factory PayAmount.drain() = PayAmount_Drain;
}

class PayOnchainRequest {
  final String address;
  final PreparePayOnchainResponse prepareResponse;

  const PayOnchainRequest({required this.address, required this.prepareResponse});

  @override
  int get hashCode => address.hashCode ^ prepareResponse.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PayOnchainRequest &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          prepareResponse == other.prepareResponse;
}

class Payment {
  final String? destination;
  final String? txId;
  final String? unblindingData;
  final int timestamp;
  final BigInt amountSat;
  final BigInt feesSat;
  final BigInt? swapperFeesSat;
  final PaymentType paymentType;
  final PaymentState status;
  final PaymentDetails details;

  const Payment({
    this.destination,
    this.txId,
    this.unblindingData,
    required this.timestamp,
    required this.amountSat,
    required this.feesSat,
    this.swapperFeesSat,
    required this.paymentType,
    required this.status,
    required this.details,
  });

  @override
  int get hashCode =>
      destination.hashCode ^
      txId.hashCode ^
      unblindingData.hashCode ^
      timestamp.hashCode ^
      amountSat.hashCode ^
      feesSat.hashCode ^
      swapperFeesSat.hashCode ^
      paymentType.hashCode ^
      status.hashCode ^
      details.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Payment &&
          runtimeType == other.runtimeType &&
          destination == other.destination &&
          txId == other.txId &&
          unblindingData == other.unblindingData &&
          timestamp == other.timestamp &&
          amountSat == other.amountSat &&
          feesSat == other.feesSat &&
          swapperFeesSat == other.swapperFeesSat &&
          paymentType == other.paymentType &&
          status == other.status &&
          details == other.details;
}

@freezed
sealed class PaymentDetails with _$PaymentDetails {
  const PaymentDetails._();

  const factory PaymentDetails.lightning({
    required String swapId,
    required String description,
    required int liquidExpirationBlockheight,
    String? preimage,
    String? invoice,
    String? bolt12Offer,
    String? paymentHash,
    String? destinationPubkey,
    LnUrlInfo? lnurlInfo,
    String? bip353Address,
    String? payerNote,
    String? claimTxId,
    String? refundTxId,
    BigInt? refundTxAmountSat,
  }) = PaymentDetails_Lightning;
  const factory PaymentDetails.liquid({
    required String destination,
    required String description,
    required String assetId,
    AssetInfo? assetInfo,
    LnUrlInfo? lnurlInfo,
    String? bip353Address,
    String? payerNote,
  }) = PaymentDetails_Liquid;
  const factory PaymentDetails.bitcoin({
    required String swapId,
    required String bitcoinAddress,
    required String description,
    required bool autoAcceptedFees,
    required int liquidExpirationBlockheight,
    required int bitcoinExpirationBlockheight,
    String? lockupTxId,
    String? claimTxId,
    String? refundTxId,
    BigInt? refundTxAmountSat,
  }) = PaymentDetails_Bitcoin;
}

enum PaymentMethod { lightning, bolt11Invoice, bolt12Offer, bitcoinAddress, liquidAddress }

enum PaymentState {
  created,
  pending,
  complete,
  failed,
  timedOut,
  refundable,
  refundPending,
  waitingFeeAcceptance,
}

enum PaymentType { receive, send }

class PrepareBuyBitcoinRequest {
  final BuyBitcoinProvider provider;
  final BigInt amountSat;

  const PrepareBuyBitcoinRequest({required this.provider, required this.amountSat});

  @override
  int get hashCode => provider.hashCode ^ amountSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareBuyBitcoinRequest &&
          runtimeType == other.runtimeType &&
          provider == other.provider &&
          amountSat == other.amountSat;
}

class PrepareBuyBitcoinResponse {
  final BuyBitcoinProvider provider;
  final BigInt amountSat;
  final BigInt feesSat;

  const PrepareBuyBitcoinResponse({required this.provider, required this.amountSat, required this.feesSat});

  @override
  int get hashCode => provider.hashCode ^ amountSat.hashCode ^ feesSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareBuyBitcoinResponse &&
          runtimeType == other.runtimeType &&
          provider == other.provider &&
          amountSat == other.amountSat &&
          feesSat == other.feesSat;
}

class PrepareLnUrlPayRequest {
  final LnUrlPayRequestData data;
  final PayAmount amount;
  final String? bip353Address;
  final String? comment;
  final bool? validateSuccessActionUrl;

  const PrepareLnUrlPayRequest({
    required this.data,
    required this.amount,
    this.bip353Address,
    this.comment,
    this.validateSuccessActionUrl,
  });

  @override
  int get hashCode =>
      data.hashCode ^
      amount.hashCode ^
      bip353Address.hashCode ^
      comment.hashCode ^
      validateSuccessActionUrl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareLnUrlPayRequest &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          amount == other.amount &&
          bip353Address == other.bip353Address &&
          comment == other.comment &&
          validateSuccessActionUrl == other.validateSuccessActionUrl;
}

class PrepareLnUrlPayResponse {
  final SendDestination destination;
  final BigInt feesSat;
  final LnUrlPayRequestData data;
  final PayAmount amount;
  final String? comment;
  final SuccessAction? successAction;

  const PrepareLnUrlPayResponse({
    required this.destination,
    required this.feesSat,
    required this.data,
    required this.amount,
    this.comment,
    this.successAction,
  });

  @override
  int get hashCode =>
      destination.hashCode ^
      feesSat.hashCode ^
      data.hashCode ^
      amount.hashCode ^
      comment.hashCode ^
      successAction.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareLnUrlPayResponse &&
          runtimeType == other.runtimeType &&
          destination == other.destination &&
          feesSat == other.feesSat &&
          data == other.data &&
          amount == other.amount &&
          comment == other.comment &&
          successAction == other.successAction;
}

class PreparePayOnchainRequest {
  final PayAmount amount;
  final int? feeRateSatPerVbyte;

  const PreparePayOnchainRequest({required this.amount, this.feeRateSatPerVbyte});

  @override
  int get hashCode => amount.hashCode ^ feeRateSatPerVbyte.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PreparePayOnchainRequest &&
          runtimeType == other.runtimeType &&
          amount == other.amount &&
          feeRateSatPerVbyte == other.feeRateSatPerVbyte;
}

class PreparePayOnchainResponse {
  final BigInt receiverAmountSat;
  final BigInt claimFeesSat;
  final BigInt totalFeesSat;

  const PreparePayOnchainResponse({
    required this.receiverAmountSat,
    required this.claimFeesSat,
    required this.totalFeesSat,
  });

  @override
  int get hashCode => receiverAmountSat.hashCode ^ claimFeesSat.hashCode ^ totalFeesSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PreparePayOnchainResponse &&
          runtimeType == other.runtimeType &&
          receiverAmountSat == other.receiverAmountSat &&
          claimFeesSat == other.claimFeesSat &&
          totalFeesSat == other.totalFeesSat;
}

class PrepareReceiveRequest {
  final PaymentMethod paymentMethod;
  final ReceiveAmount? amount;

  const PrepareReceiveRequest({required this.paymentMethod, this.amount});

  @override
  int get hashCode => paymentMethod.hashCode ^ amount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareReceiveRequest &&
          runtimeType == other.runtimeType &&
          paymentMethod == other.paymentMethod &&
          amount == other.amount;
}

class PrepareReceiveResponse {
  final PaymentMethod paymentMethod;
  final BigInt feesSat;
  final ReceiveAmount? amount;
  final BigInt? minPayerAmountSat;
  final BigInt? maxPayerAmountSat;
  final double? swapperFeerate;

  const PrepareReceiveResponse({
    required this.paymentMethod,
    required this.feesSat,
    this.amount,
    this.minPayerAmountSat,
    this.maxPayerAmountSat,
    this.swapperFeerate,
  });

  @override
  int get hashCode =>
      paymentMethod.hashCode ^
      feesSat.hashCode ^
      amount.hashCode ^
      minPayerAmountSat.hashCode ^
      maxPayerAmountSat.hashCode ^
      swapperFeerate.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareReceiveResponse &&
          runtimeType == other.runtimeType &&
          paymentMethod == other.paymentMethod &&
          feesSat == other.feesSat &&
          amount == other.amount &&
          minPayerAmountSat == other.minPayerAmountSat &&
          maxPayerAmountSat == other.maxPayerAmountSat &&
          swapperFeerate == other.swapperFeerate;
}

class PrepareRefundRequest {
  final String swapAddress;
  final String refundAddress;
  final int feeRateSatPerVbyte;

  const PrepareRefundRequest({
    required this.swapAddress,
    required this.refundAddress,
    required this.feeRateSatPerVbyte,
  });

  @override
  int get hashCode => swapAddress.hashCode ^ refundAddress.hashCode ^ feeRateSatPerVbyte.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareRefundRequest &&
          runtimeType == other.runtimeType &&
          swapAddress == other.swapAddress &&
          refundAddress == other.refundAddress &&
          feeRateSatPerVbyte == other.feeRateSatPerVbyte;
}

class PrepareRefundResponse {
  final int txVsize;
  final BigInt txFeeSat;
  final String? lastRefundTxId;

  const PrepareRefundResponse({required this.txVsize, required this.txFeeSat, this.lastRefundTxId});

  @override
  int get hashCode => txVsize.hashCode ^ txFeeSat.hashCode ^ lastRefundTxId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareRefundResponse &&
          runtimeType == other.runtimeType &&
          txVsize == other.txVsize &&
          txFeeSat == other.txFeeSat &&
          lastRefundTxId == other.lastRefundTxId;
}

class PrepareSendRequest {
  final String destination;
  final PayAmount? amount;

  const PrepareSendRequest({required this.destination, this.amount});

  @override
  int get hashCode => destination.hashCode ^ amount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareSendRequest &&
          runtimeType == other.runtimeType &&
          destination == other.destination &&
          amount == other.amount;
}

class PrepareSendResponse {
  final SendDestination destination;
  final PayAmount? amount;
  final BigInt? feesSat;
  final double? estimatedAssetFees;
  final BigInt? exchangeAmountSat;

  const PrepareSendResponse({
    required this.destination,
    this.amount,
    this.feesSat,
    this.estimatedAssetFees,
    this.exchangeAmountSat,
  });

  @override
  int get hashCode =>
      destination.hashCode ^
      amount.hashCode ^
      feesSat.hashCode ^
      estimatedAssetFees.hashCode ^
      exchangeAmountSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareSendResponse &&
          runtimeType == other.runtimeType &&
          destination == other.destination &&
          amount == other.amount &&
          feesSat == other.feesSat &&
          estimatedAssetFees == other.estimatedAssetFees &&
          exchangeAmountSat == other.exchangeAmountSat;
}

class Rate {
  final String coin;
  final double value;

  const Rate({required this.coin, required this.value});

  @override
  int get hashCode => coin.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Rate && runtimeType == other.runtimeType && coin == other.coin && value == other.value;
}

@freezed
sealed class ReceiveAmount with _$ReceiveAmount {
  const ReceiveAmount._();

  const factory ReceiveAmount.bitcoin({required BigInt payerAmountSat}) = ReceiveAmount_Bitcoin;
  const factory ReceiveAmount.asset({required String assetId, double? payerAmount}) = ReceiveAmount_Asset;
}

class ReceivePaymentRequest {
  final PrepareReceiveResponse prepareResponse;
  final String? description;
  final bool? useDescriptionHash;
  final String? payerNote;

  const ReceivePaymentRequest({
    required this.prepareResponse,
    this.description,
    this.useDescriptionHash,
    this.payerNote,
  });

  @override
  int get hashCode =>
      prepareResponse.hashCode ^ description.hashCode ^ useDescriptionHash.hashCode ^ payerNote.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReceivePaymentRequest &&
          runtimeType == other.runtimeType &&
          prepareResponse == other.prepareResponse &&
          description == other.description &&
          useDescriptionHash == other.useDescriptionHash &&
          payerNote == other.payerNote;
}

class ReceivePaymentResponse {
  final String destination;
  final int? liquidExpirationBlockheight;
  final int? bitcoinExpirationBlockheight;

  const ReceivePaymentResponse({
    required this.destination,
    this.liquidExpirationBlockheight,
    this.bitcoinExpirationBlockheight,
  });

  @override
  int get hashCode =>
      destination.hashCode ^ liquidExpirationBlockheight.hashCode ^ bitcoinExpirationBlockheight.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReceivePaymentResponse &&
          runtimeType == other.runtimeType &&
          destination == other.destination &&
          liquidExpirationBlockheight == other.liquidExpirationBlockheight &&
          bitcoinExpirationBlockheight == other.bitcoinExpirationBlockheight;
}

class RecommendedFees {
  final BigInt fastestFee;
  final BigInt halfHourFee;
  final BigInt hourFee;
  final BigInt economyFee;
  final BigInt minimumFee;

  const RecommendedFees({
    required this.fastestFee,
    required this.halfHourFee,
    required this.hourFee,
    required this.economyFee,
    required this.minimumFee,
  });

  @override
  int get hashCode =>
      fastestFee.hashCode ^
      halfHourFee.hashCode ^
      hourFee.hashCode ^
      economyFee.hashCode ^
      minimumFee.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RecommendedFees &&
          runtimeType == other.runtimeType &&
          fastestFee == other.fastestFee &&
          halfHourFee == other.halfHourFee &&
          hourFee == other.hourFee &&
          economyFee == other.economyFee &&
          minimumFee == other.minimumFee;
}

class RefundRequest {
  final String swapAddress;
  final String refundAddress;
  final int feeRateSatPerVbyte;

  const RefundRequest({
    required this.swapAddress,
    required this.refundAddress,
    required this.feeRateSatPerVbyte,
  });

  @override
  int get hashCode => swapAddress.hashCode ^ refundAddress.hashCode ^ feeRateSatPerVbyte.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RefundRequest &&
          runtimeType == other.runtimeType &&
          swapAddress == other.swapAddress &&
          refundAddress == other.refundAddress &&
          feeRateSatPerVbyte == other.feeRateSatPerVbyte;
}

class RefundResponse {
  final String refundTxId;

  const RefundResponse({required this.refundTxId});

  @override
  int get hashCode => refundTxId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RefundResponse && runtimeType == other.runtimeType && refundTxId == other.refundTxId;
}

class RefundableSwap {
  final String swapAddress;
  final int timestamp;
  final BigInt amountSat;
  final String? lastRefundTxId;

  const RefundableSwap({
    required this.swapAddress,
    required this.timestamp,
    required this.amountSat,
    this.lastRefundTxId,
  });

  @override
  int get hashCode =>
      swapAddress.hashCode ^ timestamp.hashCode ^ amountSat.hashCode ^ lastRefundTxId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RefundableSwap &&
          runtimeType == other.runtimeType &&
          swapAddress == other.swapAddress &&
          timestamp == other.timestamp &&
          amountSat == other.amountSat &&
          lastRefundTxId == other.lastRefundTxId;
}

class RestoreRequest {
  final String? backupPath;

  const RestoreRequest({this.backupPath});

  @override
  int get hashCode => backupPath.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RestoreRequest && runtimeType == other.runtimeType && backupPath == other.backupPath;
}

class RouteHint {
  final List<RouteHintHop> hops;

  const RouteHint({required this.hops});

  @override
  int get hashCode => hops.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is RouteHint && runtimeType == other.runtimeType && hops == other.hops;
}

class RouteHintHop {
  final String srcNodeId;
  final String shortChannelId;
  final int feesBaseMsat;
  final int feesProportionalMillionths;
  final BigInt cltvExpiryDelta;
  final BigInt? htlcMinimumMsat;
  final BigInt? htlcMaximumMsat;

  const RouteHintHop({
    required this.srcNodeId,
    required this.shortChannelId,
    required this.feesBaseMsat,
    required this.feesProportionalMillionths,
    required this.cltvExpiryDelta,
    this.htlcMinimumMsat,
    this.htlcMaximumMsat,
  });

  @override
  int get hashCode =>
      srcNodeId.hashCode ^
      shortChannelId.hashCode ^
      feesBaseMsat.hashCode ^
      feesProportionalMillionths.hashCode ^
      cltvExpiryDelta.hashCode ^
      htlcMinimumMsat.hashCode ^
      htlcMaximumMsat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RouteHintHop &&
          runtimeType == other.runtimeType &&
          srcNodeId == other.srcNodeId &&
          shortChannelId == other.shortChannelId &&
          feesBaseMsat == other.feesBaseMsat &&
          feesProportionalMillionths == other.feesProportionalMillionths &&
          cltvExpiryDelta == other.cltvExpiryDelta &&
          htlcMinimumMsat == other.htlcMinimumMsat &&
          htlcMaximumMsat == other.htlcMaximumMsat;
}

@freezed
sealed class SendDestination with _$SendDestination {
  const SendDestination._();

  const factory SendDestination.liquidAddress({
    required LiquidAddressData addressData,
    String? bip353Address,
  }) = SendDestination_LiquidAddress;
  const factory SendDestination.bolt11({required LNInvoice invoice, String? bip353Address}) =
      SendDestination_Bolt11;
  const factory SendDestination.bolt12({
    required LNOffer offer,
    required BigInt receiverAmountSat,
    String? bip353Address,
  }) = SendDestination_Bolt12;
}

class SendPaymentRequest {
  final PrepareSendResponse prepareResponse;
  final bool? useAssetFees;
  final String? payerNote;

  const SendPaymentRequest({required this.prepareResponse, this.useAssetFees, this.payerNote});

  @override
  int get hashCode => prepareResponse.hashCode ^ useAssetFees.hashCode ^ payerNote.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendPaymentRequest &&
          runtimeType == other.runtimeType &&
          prepareResponse == other.prepareResponse &&
          useAssetFees == other.useAssetFees &&
          payerNote == other.payerNote;
}

class SendPaymentResponse {
  final Payment payment;

  const SendPaymentResponse({required this.payment});

  @override
  int get hashCode => payment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendPaymentResponse && runtimeType == other.runtimeType && payment == other.payment;
}

class SignMessageRequest {
  final String message;

  const SignMessageRequest({required this.message});

  @override
  int get hashCode => message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SignMessageRequest && runtimeType == other.runtimeType && message == other.message;
}

class SignMessageResponse {
  final String signature;

  const SignMessageResponse({required this.signature});

  @override
  int get hashCode => signature.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SignMessageResponse && runtimeType == other.runtimeType && signature == other.signature;
}

@freezed
sealed class SuccessAction with _$SuccessAction {
  const SuccessAction._();

  const factory SuccessAction.aes({required AesSuccessActionData data}) = SuccessAction_Aes;
  const factory SuccessAction.message({required MessageSuccessActionData data}) = SuccessAction_Message;
  const factory SuccessAction.url({required UrlSuccessActionData data}) = SuccessAction_Url;
}

@freezed
sealed class SuccessActionProcessed with _$SuccessActionProcessed {
  const SuccessActionProcessed._();

  const factory SuccessActionProcessed.aes({required AesSuccessActionDataResult result}) =
      SuccessActionProcessed_Aes;
  const factory SuccessActionProcessed.message({required MessageSuccessActionData data}) =
      SuccessActionProcessed_Message;
  const factory SuccessActionProcessed.url({required UrlSuccessActionData data}) = SuccessActionProcessed_Url;
}

class Symbol {
  final String? grapheme;
  final String? template;
  final bool? rtl;
  final int? position;

  const Symbol({this.grapheme, this.template, this.rtl, this.position});

  @override
  int get hashCode => grapheme.hashCode ^ template.hashCode ^ rtl.hashCode ^ position.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Symbol &&
          runtimeType == other.runtimeType &&
          grapheme == other.grapheme &&
          template == other.template &&
          rtl == other.rtl &&
          position == other.position;
}

class UrlSuccessActionData {
  final String description;
  final String url;
  final bool matchesCallbackDomain;

  const UrlSuccessActionData({
    required this.description,
    required this.url,
    required this.matchesCallbackDomain,
  });

  @override
  int get hashCode => description.hashCode ^ url.hashCode ^ matchesCallbackDomain.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UrlSuccessActionData &&
          runtimeType == other.runtimeType &&
          description == other.description &&
          url == other.url &&
          matchesCallbackDomain == other.matchesCallbackDomain;
}

class WalletInfo {
  final BigInt balanceSat;
  final BigInt pendingSendSat;
  final BigInt pendingReceiveSat;
  final String fingerprint;
  final String pubkey;
  final List<AssetBalance> assetBalances;

  const WalletInfo({
    required this.balanceSat,
    required this.pendingSendSat,
    required this.pendingReceiveSat,
    required this.fingerprint,
    required this.pubkey,
    required this.assetBalances,
  });

  @override
  int get hashCode =>
      balanceSat.hashCode ^
      pendingSendSat.hashCode ^
      pendingReceiveSat.hashCode ^
      fingerprint.hashCode ^
      pubkey.hashCode ^
      assetBalances.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WalletInfo &&
          runtimeType == other.runtimeType &&
          balanceSat == other.balanceSat &&
          pendingSendSat == other.pendingSendSat &&
          pendingReceiveSat == other.pendingReceiveSat &&
          fingerprint == other.fingerprint &&
          pubkey == other.pubkey &&
          assetBalances == other.assetBalances;
}
